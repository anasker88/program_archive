# コンパイラ実験第8回レポート 阿部 桃大

## 問1

本課題ではリストスケジューリングを実装した。実装した戦略は以下の通りである。

1. 実行時間優先
2. 資源優先

### 実行時間優先

実行時間優先では、クリティカルパスを最優先で計算できるようにスケジューリングする。具体的には、`ready_set`の中で最も依存命令のレイテンシが大きい命令を選択する。また、資源/レイテンシ制約についても、それにより実行できない命令がある場合は、その命令を選択しない。

### 資源優先

資源優先ではとにかく先に実行された命令に依存する命令を実行するようにスケジューリングする。具体的には、優先度を先行命令の命令数とし、`ready_set`の中で最も優先度が高い命令を選択する。また、資源/レイテンシ制約により実行できない命令が選択された場合には、その命令が実行できるようになるまで待機する。こうして、同じ資源を使う命令をできるだけ近い時刻に実行するようにする。

### 実行例

このプログラムは、以下のような入力を受け取り、それをスケジューリングする。

```txt
jobの数
依存関係の数
各jobの種類(1: alu, 2:fpu, 3:mem)
依存関係の始点と終点
```

例えば、スライドの例は以下のようになる。

```txt
8
7
3 3 3 3 3 2 3 2
0 1
2 3
5 6
1 4
3 4
4 7
6 7
```

この入力を実行すると、以下のような出力が得られる。

```txt
time_priority
   time: 10
   done_order: 0 2 1 3 5 4 6 7
resource_priority
   time: 14
   done_order: 0 1 2 3 4 5 6 7
```

この出力について考える。

まず、`time_priority`については、`time`が10であり、命令数8に対して無駄なく実行できていることがわかる。また、`done_order`については、クリティカルパスの命令が最初に実行されていることがわかる。

次に、`resource_priority`については、`time`が14であり、命令数8に対して無駄が多い。また、`done_order`については、依存関係のある命令ができるだけ近い時刻に実行されていることがわかる。

### 並列化

最後にこのアルゴリズムを並列実行を想定して改変した場合を考える。この改変については、`ready_set`から命令を選択するときに、複数の命令を選択するようにするだけである。この改変により、並列実行を想定したアルゴリズムが実装できる。

ただし、資源の競合により実行できない命令が選択された場合には、その命令が実行できるようになるまで待機する、もしくは、その命令を選択しないようにする必要がある。前者の場合は、資源の競合が解消されるまで待機することになるため、並列実行による高速化の効果が提言することが想定される。一方で、後者の場合は、資源の競合が解消されるまで待機することなく、他の命令を選択することができるため、並列実行による高速化の効果が期待できる。

### 備考

今回のコードは、繰り返し改変しながら使うことを想定していないため、gitを使わず、zipで提出することにしました。問題があれば、ご連絡ください。
