05-231001 阿部　桃大

問1:
出力例
# sum_to 5;;
- : int = 15
# is_prime 100;;
- : bool = false
# is_prime 101;;
- : bool = true
# gcd 60 96;;
- : int = 12

問2:
出力例
# twice sqr 3;;
- : int = 81
# repeat sqr 3 2;;
- : int = 256

問3:
出力例
# sum_to_fix 10;;
- : int = 55
# is_prime_fix 97;;
- : bool = true
# is_prime_fix 98;;
- : bool = false
# gcd_fix 105 147;;
- : int = 21

考察
関数fixは、自身を定義に含む関数と初期値を受け取り、初期値に対して出力が定まるまで繰り返し関数を計算するようなものであるから、コードにあるような漸化式のような関数を与えることで、それを繰り返し適用して求めたい答えを計算してくれる。

問4:
出力例
# let lst=[2;3;4];;
val lst : int list = [2; 3; 4]
# let sub x y =x * y;;
val sub : int -> int -> int = <fun>
# fold_right sub lst 5;;
- : int = 120
# fold_left sub 5 lst;;
- : int = 120

考察
一般式をパッと見ただけではいずれの場合も空リストの際の出力はどうすればよいかわからないが、漸化式を見ればeが初期値に当たるとわかる。また、fold_leftのほうは末尾再帰による定義が可能であり、メモリへの負荷を減らすことに成功している。

問5:
出力例
#append [1;2;3] [4;5];;
- : int list = [1; 2; 3; 4; 5]
# filter (fun x -> x mod 2 = 0) [0;1;2;3;4;5];;
- : int list = [0; 2; 4]

考察
appendでは左につけるリストの左端を取り出し、それを用いて漸化的にappendの出力結果を表現し、ループを潜るごとにxsの長さが１つずつ短くなるようにしている。filterでも同様で、関数ｆの適用はリストから左端を取り出した際にその要素に対し行っている。

問6:
出力例
# append_left [0;1;2] [3;4;5];;
- : int list = [0; 1; 2; 3; 4; 5]
# append_right [0;1;2] [3;4;5];;
- : int list = [0; 1; 2; 3; 4; 5]
# filter_left (fun x -> x mod 2 = 0) [0;1;2;3;4;5];;
- : int list = [0; 2; 4]
# filter_right (fun x -> x mod 2 = 0) [0;1;2;3;4;5];;
- : int list = [0; 2; 4]

考察
演算子::を用いて左端に要素を追加できるというリストの性質上、関数適用を右から左へと順に行うfold_rightを用いた実装は比較的容易であった。一方、関数適用を左から右へ順にに行うfold_leftを用いる場合はリストの右端に追加する手段が必要であり、今回はそれを行う関数add_end_filterを実装し、それを用いて目的の関数を実装した。
演算子::の性質からして、fold_rightを用いた関数が一番書きやすく、fold関数を用いない関数がそれに続き、fold_leftを用いた関数が一番書きにくかった。
実行速度の観点からみても、右端に要素を追加する関数add_end_filterは処理に時間がかかり、fold_leftによる実装はそれを何回も呼び出すので、速度は遅い。

問7:
出力例
# perm [0;1;2;3];;
- : int list list =
[[0; 1; 2; 3]; [1; 0; 2; 3]; [1; 2; 0; 3]; [1; 2; 3; 0]; [0; 2; 1; 3];
 [2; 0; 1; 3]; [2; 1; 0; 3]; [2; 1; 3; 0]; [0; 2; 3; 1]; [2; 0; 3; 1];
 [2; 3; 0; 1]; [2; 3; 1; 0]; [0; 1; 3; 2]; [1; 0; 3; 2]; [1; 3; 0; 2];
 [1; 3; 2; 0]; [0; 3; 1; 2]; [3; 0; 1; 2]; [3; 1; 0; 2]; [3; 1; 2; 0];
 [0; 3; 2; 1]; [3; 0; 2; 1]; [3; 2; 0; 1]; [3; 2; 1; 0]]:

考察
場合の数的な問題であるので、再起を用いて実装するのが自然である。左端の要素を除いたリストの順列と元のリストの順列の関係を考えると、後者は前者のそれぞれの要素に左端の要素をどこかに挿入したすべてのパターンを網羅したものとなっている。今回の実装では、リストにある要素を挿入したすべてのパターンをリストのリストとして返す関数insert_allを定義し、これをmap関数によって左端の要素を除いたリストの順列すべてに適用し、得られたリストをconcat関数によって結合することで順列のリストを得た。なお、mapおよびconcatはライブラリ内にも用意されているが、今回は自前で定義した。
