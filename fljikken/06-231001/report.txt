問1
出力例:
# let f= fun x -> x + x;;
val f = <fun>
# f 1;;
- = 2
# let a = 10 in let f = fun x -> x+ a in let a=20 in f 5;;
- = 15
# (fun f -> fun x -> f (f x)) (fun x ->x+ x) 1;;
- = 4

考察:
関数の定義自体は本質的な部分ではほかの変数の定義と同様で、関数の作用を変数と対応させて環境に記録すればよい。
ただ、関数内で用いられた各種変数の値については関数適用の際に必要となるため、関数定義の際の環境についても併せて覚えておく必要がある。
すなわち、関数定義では関数の作用と現在の環境のセットをVFUNとして環境に登録し、関数適用の際に現在の環境下で引数を評価したのち、関数定義当時の環境下で値を評価すればよい。

問2:
出力例:
# let rec sum x = if x < 1 then 0 else x + sum (x-1);;
val sum = <fun>
# sum 10;;
- = 55
# let rec fib x = if x < 2 then x else fib (x-1) + fib (x-2);;
val fib = <fun>
# fib 10;;
- = 55
# let rec fib2 x = if x<2 then x else fib2 (x-1) + fib2 (x-2) in fib2 10;;
- = 55

考察:
クロージャーと関数適用を工夫する方法で行った。
関数定義の際は、通常の関数定義に加えてのちの関数適用で必要となる関数名を合わせて記憶したVRECFUN(id,x,e,env)として環境に登録し、関数適用の際に再帰関数に登録した環境に自身を加えて評価することで、再帰的な関数の適用を行っている。

問3:
出力例:
# let rec even x = if x =0 then true else odd (x-1) and odd x = if x= 0 then false else even (x-1);;
val even = <fun>
val odd = <fun>
# even 7;;
- = false
# odd 7;;
- = true

考察:
問4と同様、環境を工夫する方法で行ったため、そちらも併せて参考にされたい。
注意すべき点としては、同時に定義されたすべての再帰関数を現在の環境に追加し、それをすべての再帰関数に対応させる処理を行う必要があり、ダミー環境oenvの局所定義の内部で再帰的にその処理を行わなくてはならないことだ。
また、複数の再帰関数が同時に定義されることになるため、メイン関数内のprintの仕方などもそれに対応させた。具体的には、eval_commandの返り値が(変数名、新しい環境、変数の値)であったのを((変数名、変数の値)のリスト、新しい環境)と変更し、これに対して繰り返しprintなどの処理を行うようにした。

問4:
出力例:
# let rec sum x = if x < 1 then 0 else x + sum (x-1);;
val sum = <fun>
# sum 10;;
- = 55
# let rec fib x = if x < 2 then x else fib (x-1) + fib (x-2) in fib 10;;
- = 55
考察:
環境を工夫する方法で行った。
クロージャーに環境ではなく環境への参照を持たせ、クロージャーが持つ環境への参照に自分自身を登録することで、再帰的な呼び出しを可能にした。
関数適用の際には、参照を外して通常の関数と同様に処理することができる。