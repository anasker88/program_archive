問1
考察:
任意の２要素についてもancestorを問い合わせると無限ループに入ってエラーとなる。
ancestor(X,Y)の真偽を調べる際には適当なZを生成し、そのZを用いてancestor(Y,Z)を調べる。すると再び適当なWを生成し、そのZを用いてancestor(Z,W)を調べることになる。このように一つ目の条件式が新たな変数を含んだancestor自身となっているために、ancestorの真偽を調べる無限ループができてしまっている。

問2
実行例:
?- ['toi2.pl'].
true.

?- nat_list([z, s(z), z]).
true.

?- nat_list([z, X]).
X = z ;
X = s(z) ;
X = s(s(z)) ;
X = s(s(s(z))) ;
X = s(s(s(s(z)))) .

?- nat_list(X).
X = [] ;
X = [z] ;
X = [z, z] ;
X = [z, z, z] ;
X = [z, z, z, z] ;
X = [z, z, z, z, z] ;
X = [z, z, z, z, z, z] .

?- nat_list(X),X=s(Y).
(ここでフリーズ)

考察:
nat_list([N|X])の探索を行う際には、まずはnat(N)の探索を行い、最初のルールによる答えzを得て先に進む。続いてnat_list(X)の探索を行うと、これも最初のルールによる答え[]を得るので、nat_list(X)の実行結果では[]の次に[z]を得る。
ここから探索を再開すると、prologでは深さ優先探索を行うため、nat_list(X)の次の候補を探し始め、これは先にみたように[z]なので[z,z]を次に得る。こうして探索再開時に常にnat_listのほうの探索を行ってしまうために、先頭要素側の探索が行われることはなく、探索ではzのみからなるリストしか得られない。

問3
実行例:
?- lose(1,-1,[[0,0,0],[0,0,0],[0,0,0]]).
false.

?- win(1,-1,[[0,0,0],[0,0,0],[0,0,0]]).
false.

?- win(1,-1,[[1,0,0],[-1,0,0],[0,0,0]]).
true ;
true ;
true ;
false.

?- win(1,-1,[[0,0,0],[-1,1,0],[0,0,0]]).
true ;
true ;
true ;
true ;
true ;
true.

?- win(1,-1,[[0,1,0],[-1,0,0],[0,0,0]]).
true ;
true ;
false.
考察:
実装の意図についてはコード内のコメントも併せて参考にされたい。
盤面は3*3のリストのリストとし、空のマスは0とすることにした。プレイヤーは1,-1として、それぞれ盤面上に値を上書きしていった。
スライドの通りに勝ち負けの条件を実装した。B から一手進めた任意の局面 B' について win(Q, B')という条件は「B から一手進めた局面 B' で win(Q, B')でないものが存在しない」と読み替え、カットを用いて表現した。