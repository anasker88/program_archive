問1
・論理的解釈ではtrueであることの証明
プログラムは以下のように解釈される。
1. eq (a, b)
2. eq (c, b)
3. ∀X∀Y∀Z. eq (X, Y) ∧ eq (Y, Z) → eq(X, Z)
4. ∀X∀Y. eq (Y,X) → eq(X, Y)

仮定2より、
eq(c,b)
さらに仮定4より
eq(b,c)
さらに仮定1より
eq(a,b)∧ eq(b,c)
仮定3のX=a,Y=b,Z=cの場合より、
eq(a,c)

・Prolog 処理系で ?- eq(a,c). を問い合わせるとどうなるか.それはなぜか
問い合わせの結果は無限ループとなり、エラーを吐く。
eq(a,c)の問い合わせを行うと、eq(X, Z) :- eq(X, Y), eq(Y, Z).のルールに従い探索を行う。X=aとなり、eq(a, Y)を成立させるものとしてY=bが代入される。
つづいてeq(b, Z)を満足するZの探索が行われるが、これはルールの1,2行目からは発見できないので、再びeq(X, Z) :- eq(X, Y), eq(Y, Z).のルールに従い探索を行う。
今回は1行目に従いX=a,Y=bとなり、再びeq(b, Z)を満足するZの探索が行われる。
こうして、問い合わせの結果は無限ループに陥る。

・解決策
探索を行う際に、prologでは前のルールから順に深さ優先探索で行われるが、幅優先探索で探索を行うことで無限ループとなる場合があったとしても探索を行うことができる。

問2
・論理的解釈では ?- test. の問合せの結果はどうなると考えられるか
変数Xについてq(X,Y)の形の式はY=f(X)の場合のみ成立する。
つまり、任意の変数Xについて、q(X,X)は成立しないので、test.の問い合わせ結果は論理的には偽になるべきである。

・実際に ?- test. を Prolog処理系に問い合わせるとどうなるか.どうしてそうなるのか.
結果はtrue.となる。test.を問い合わせるとq(X, X).を成立させるXの問い合わせを行うが、q(X, f(X)).がマッチして単一化を行おうとする。
この時変数の出現チェックが行われないため、X=X,X=f(X)に従って単一化が行われ、X=f(X)なる代入がq(X, X).を満たすものとされてしまい、これをもってすべてのゴールが満足されてしまう。
こうして問い合わせ結果は誤ってtrueとなる。

問3:
・論理的解釈から期待される答えは何か
明らかにX=b
・実際に問い合わせた結果とその理由
\+ p(X),q(X).
という問い合わせを行うとfalseを返してくる。
これはprologの処理系で式が変数を含んでいても失敗による否定を用いようとするからで、今回は\+ p(X)が一つ目のゴールになってしまっているためにnotの後に変数が残ったまま探索を行おうとして失敗する。
・論理的解釈と Prolog処理系の応答が一致するように問合せを書き換えよ
否定が評価される際に内部の変数をなくすため、ゴールの順番をもととは逆にして
q(X), \+ p(X).
とすればよい。

発展1:
・r(a) がプログラムの論理的帰結であることを示せ
p(a)は必ずtrueもしくはfalseのいずれかである。
p(a)がtrueの場合は1行目よりr(a)はtrue。
p(a)がfalseの場合は2行目よりr(a)はtrue。
よっていずれの場合もr(a)はtrueだから、r(a)はtrue。
・Prolog処理系はこの問合せにどう答えるか。それはなぜか。
prologでこの問い合わせを行うと、無限ループに陥って答えを返さない。
この問い合わせを行った際、処理系は1行目のルールに従いp(a)の値を得ようとして3行目のルールを使う。するとp(f(a))のあたいが必要となるので再び3行目のルールに従い、今度はp(f(f(a)))の値を要求する。
こうして無限に3行目のルールを使って値を調べようとするために無限ループに陥る。
